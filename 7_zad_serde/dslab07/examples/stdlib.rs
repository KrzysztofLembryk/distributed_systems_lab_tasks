use std::net::IpAddr;
use std::str::FromStr;

fn parse_example() {
    // There is a limited string parsing in the Rust standard library
    // for types implementing the `FromStr` trait.
    let signed: i32 = "123".parse().unwrap();
    let ip: IpAddr = "127.0.0.12".parse().unwrap();
    println!("Parsed int: {signed} and an IP address: {ip}");

    // Parsing can also fail. Here we call the trait method:
    let failed = u32::from_str("-12");
    println!("Parsing may fail: {failed:?}");
}

fn as_bytes_example() {
    // Multiple types can be viewed as bytes and be converted to them:
    let utf8: &[u8] = "Żółáĉ".as_bytes();
    let little_endian: [u8; 2] = 42i16.to_le_bytes();
    println!("Bytes view: {utf8:?} and {little_endian:?}");

    // Sometimes, the other conversion is trivial or may fail:
    let int_from_bytes = u16::from_le_bytes(little_endian);
    let string = str::from_utf8(utf8).unwrap();
    println!("Recovered : {string:?} and {int_from_bytes:?}");
}

fn enum_to_int() {
    // Enums with unit-like fields can be converted to their discriminator.
    // First, we enforce the discriminator representation:
    #[derive(Debug, Copy, Clone)]
    #[repr(u8)]
    enum Variants {
        _One = 1,
        Two,
    }

    let variant: Variants = Variants::Two;
    // We get the value by using a special-case of the casting operator.
    let discriminator: u8 = variant as u8;
    println!("Discriminator of {variant:?} is {discriminator}");

    // The other way is not implemented
    // let variant = 2 as Variants;
    // let variant = Variants::try_from(2);
    // We can do the other conversion only with unsafe code
    // or with some extra code for the enum (e.g., generated by a helper crate).
}

fn main() {
    parse_example();
    as_bytes_example();
    enum_to_int();
}
